# 数据处理逻辑说明：日期字段的处理

在处理 CSMAR 的金融数据时，日期字段通常以 `YYYY-MM-DD` 的格式出现（例如 `2020-12-31`）。而在我们的研究中（计算年度 TFP），我们只需要关注**年份**。

以下是代码中处理日期的标准逻辑：

### 1. 转换逻辑
我们使用了 Pandas 库的 `pd.to_datetime` 方法，配合 `.dt.year` 属性提取年份。

```python
# 原始数据：2020-12-31 (String 或 Object 类型)
staff['Year'] = pd.to_datetime(staff['Reptdt']).dt.year.astype('int64')
# 处理后：2020 (Int64 类型)
```

### 2. 为什么只保留年份？
*   **统一时间粒度**：不同报表的截止日期可能略有不同（虽然大部分是 12-31），统一转成年份可以避免合并时的匹配错误。
*   **去重逻辑**：
    ```python
    staff = staff.sort_values(['Stkcd', 'Year']).drop_duplicates(['Stkcd', 'Year'], keep='last')
    ```
    我们将日期转换为年份后，对于同一年如果有多条记录（比如季报、半年报），我们通过 `drop_duplicates(keep='last')` 默认保留**该年最后一条**记录（通常是年报数据），从而确保数据的唯一性和准确性。

### 3. 特殊情况处理
对于 `CG_Ybasic.xlsx` 这种治理文件，它的日期字段名是 `Reptdt`（统计截止日期），而财务报表通常是 `Accper`（会计期间）。我们在重命名时统一改为了 `Year`，方便后续的 `pd.merge` 操作。

---
**总结**：代码中的处理方式是：**读取日期 -> 转为 datetime 对象 -> 提取年份 -> 转为整数 -> 基于年份去重**。这一套组合拳确保了我们在合并数据时，只会匹配到同一年份的数据，不会出现“张冠李戴”的情况。
